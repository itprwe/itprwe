
1.记录每次改动
2.linus 在1991创建了开源的linux
3.C开发出的git
4.集中式：版本是集中放在中央服务器中的，需要联网
5.分布式，每个人的电脑就是一个中央服务器，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便
6.输入git看是否安装了git

7.因为git是分布式版本控制系统，所以，每个机器要区别，名字和邮件地址（git config --global user.name "Your Name" ; git config --global user.email "Your Email"）
输入git config --list 查看是否配置了用户信息和邮箱，
修改配置git config --global --replace-all user.email "输入你的邮箱" 或者 git config --global  user.name "Your name"

8.git config --global 中的文本编辑器，差异分析工具等等

9.git config的增（git config --global --add configName configValue）删（git config  --global --unset configName   (只针对存在唯一值的情况)）改（git config --global configName configValue）查（git config --global configName/--list）

10.git init 把当前目录变为git可以管理的仓库

11.git add  filename/. 告诉Git，把文件添加到仓库(Unix的哲学是“没有消息就是好消息”)，注意，可反复多次使用，添加多个文件

12.git commit  -m <message>告诉Git，把文件提交到仓库(git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录)

13. git status  命令可以让我们时刻掌握仓库当前的状态，掌握工作区的状态

14.git diff  filename/(不输入)   查看具体修改了什么内容（工作区和版本库对比）

15.git log 查看历史记录，显示从最近到最远的提交日志，git log --pretty=oneline（输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数）
	按 q 键退出

16.gitbash中可以用clear清屏 

17. git reset --hard HEAD^  回退到上一个版本，首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100

18.git reset --hard 1094a（commit id）  指定回到某个版本

19.git reflog 记录你的每一次命令

20.工作区  暂存区 git当前分支（git add把文件从工作区添加到暂存区，git commit把暂存区的所有内容提交到当前分支）（因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以git commit就是往master分支上提交更改）

21.每次修改，如果不用git add到暂存区，那就不会加入到commit

22.git checkout -- filename  把文件在工作区的修改全部撤销（自修改后还没有被放到暂存区，撤销修改就回到和版本库一模一样的状态；已经添加到暂存区后，又作了修改，撤销修改就回到添加到暂存区后的状态）

23.git checkout -- filename 命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令

24.git reset HEAD <file> 可以把暂存区的修改撤销掉（unstage），重新放回工作区

25.git rm filename  删除， 然后commit 提交

26.先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的

27.删错了，可以用git reset HEAD    git checkout -- filename 撤回

28.github远程git仓库

29.第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），
				 创建SSH Key：一路回车，可不设置密码，
                 ssh-keygen -t rsa -C "youremail@example.com"，
				 可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人；
	第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容，
				为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。
				当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。
				在GitHub上免费托管的Git仓库，任何人都可以看到（但只有你自己才能改）。所以，不要把敏感信息放进去。

30.在本地有一个仓库，又在github建了一个仓库，将两个关联起来，然后，把本地仓库的内容推送到GitHub仓库
	git remote add origin git@github.com:itprwe/itprwe.git  或者  git remote add origin https://github.com/itprwe/itprwe.git  --（git@github.com:itprwe（github账号名）/itprwe（github要关联的仓库名）.git）

31.添加后，远程库分支的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库分支

32.ssh-keygen -t rsa -C "youremail@example.com" 生成公共私有钥匙，将共有钥匙贴入github中

33.git push -u origin master 把当前分支master推送到远程
     由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令，
	 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改
	 
34.git remote -v  查看远程连接的方式

35.git remote rm origin 删除原先HTTPS的连接方式 ，， https的方式不会记住密码，用ssh方式

36.先有远程库，再远程克隆到本地  git clone https://github.com/itprwe/itprwe.git  或者  git clone git@github.com:itprwe/itprwe.git

37. git checkout -b dev  创建dev分支，然后切换到dev分支，命令加上-b参数表示创建并切换

38.git branch 查看当前分支，当前分支前面会标一个*号

39.git checkout master 切换到mater分支

40.git merge dev  合并指定分支（dev）到当前分支

41. git branch -d dev 删除dev分支

42. git branch <name> 创建分支

43.查看分支：git branch
	 创建分支：git branch <name>
	 切换分支：git checkout <name>
	 创建+切换分支：git checkout -b <name>
	 合并某分支到当前分支：git merge <name>
	 删除分支：git branch -d <name>

44.git log --graph   （git log --graph --pretty=oneline --abbrev-commit） 看到分支合并图

45.首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活
干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本
你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了
合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并

45.git merge（就是 git merge -ff）和git merge --no-ff的区别：
	通常我们把 master 作为主分支，上面存放的都是比较稳定的代码，提交频率也很低，而 develop 是用来开发特性的，
	上面会存在许多零碎的提交，快进式合并会把 develop 的提交历史混入到 master 中，搅乱 master 的提交历史
	用git merge 则分支提交历史会并到master分支上面
	
46.bug修复，新建临时分支修复bug，然后合并分支，然后删除临时分支

47.git stash 当前工作现场“储藏”起来，等以后恢复现场后继续工作

48.git stash  list查看工作现场存到什么地方了

49.git stash apply恢复，恢复后stash内容并不删除，用git stash drop删除 或者 git stash pop恢复的同时把stash内容也删了

50.git branch -D <name>强行删除

51.git reset --hard  master  git将一个分支完全覆盖另外一个分支，就是将mater分支完全覆盖当前分支

52.git remote 查看远程库的信息（远程仓库名称） 或者 git remote -v显示更详细的信息（显示了可以抓取和推送的origin的地址，如果没有推送权限，则看不到push的地址）

53.推送分支，就是把该分支上的所有本地提交推送到远程库，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上
	 git push origin master  ////  git push origin dev （将dev推送到对应的远程dev分支）
	 
54.并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？
     master分支是主分支，因此要时刻与远程同步；
	 dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；
	 bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；
	 feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发；
	
55.git clone  本地没有 repository 时，将远程 repository 整个下载过来（从远程服务器克隆一个一模一样的版本库到本地,复制的是整个版本库 --clone是将一个库复制到你的本地，是一个本地从无到有的过程）

56. git pull = git fetch + git merge  （git pull #远程主机（origin） #远程分之(next)#：#本地分之(master) ）；
	  如果远程分支是与当前分支合并，则冒号后面的部分可以省略，git pull #远程主机(origin)#　 #远程分之(next)#　相当于1. $ git fetch origin   2.$git merge origin/next ；
	  是本地有 repository 时，将远程 repository 里新的 commit 数据(如有的话)下载过来，并且与本地代码merge（从远程服务器获取到一个branch分支的更新到本地，并更新本地库 --pull是指同步一个在你本地有版本的库内容更新的部分到你的本地库）；
	  git clone 的时候，所有本地分之默认与远程主机的同名分之，建立追踪关系，也就是，本地的master分之自动“追踪”origin/master分之；
	  git 可以手动建立追踪， git branch --set-upstream master origin/next   --->指定master分之追踪到origin/next；
	  如果当前分支只有一个追踪分支，连远程主机名都可以省略。$ git pull  表示当前分之自动与唯一一个追踪分之进行合并
	  
57.git branch --set-upstream-to=origin/dev dev
	 Branch 'dev' set up to track remote branch 'dev' from 'origin'.
	 
58.多人协作的工作模式
	 首先，可以试图用git push origin <branch-name>推送自己的修改；
	 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；
	 如果合并有冲突，则解决冲突，并在本地提交；
	 没有冲突或者解决掉冲突后，再用git push origin <branch-name>推送就能成功！
	 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to <branch-name> origin/<branch-name>。
	 
59.git  rebase 将git的提交历史变为干净的直线

60.在版本库中打一个标签（tag）--其实它就是指向某个commit的指针，对应某个commit号

61.git tag v1.0  默认标签是打在最新提交的commit上

62.git tag v0.9 f52c633  打在对应的commit id上

63.git show <tagname>  查看标签信息

64.git tag -a v0.1 -m "version 0.1 released" 1094adb  用-a指定标签名，-m指定说明文字

65.git tag -d v0.1 删除标签 ，因为创建的标签都只存储在本地，不会自动推送到远程，打错的标签可以在本地安全删除。如果要推送某个标签到远程，使用命令git push origin <tagname>

66. git push origin --tags 一次性推送全部尚未推送到远程的本地标签

67.如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除 git tag -d v0.9；然后，从远程删除。删除命令也是push ： git push origin :refs/tags/v0.9

68.fork别人的项目，然后clone到本地，否则没有推送权限

69. .gitignore，把要忽略的文件名填进去，Git就会自动忽略这些文件
	  忽略操作系统自动生成的文件，比如缩略图等；
	  忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件；
	  忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件
	  
70.配置别名
	 git config --global alias.st status   告诉git  st就表示status
	 co表示checkout，ci表示commit，br表示branch
	 git config --global alias.unstage 'reset HEAD
	 git config --global alias.last 'log -1'
	 git config --global alias.lg "log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit"
	 
	 可以在配置文件中直接删除掉对应的配置(git config  --global --unset configName )
	 
===================================================================

1.create
clone an existing repository
$ git clone git/http
create a new local repository
$ git init

2.local changes
changed files in your working directory
$ git status
changes to tracked files
$ git diff 
add all current changes to the next commit 
$ git add .
add some changes in <files> to the next commit
$ git add -p <file>
commit all local changes in tracked files
$ git commit -a
commit previously staged changes
$ git commit
change the last commit 
$ git commit --amend
commit with message
$ git commit -m <message>

3.commit history
show all commits, starting with newest
$ git log
show changes over time for a specific file
git log -p <file>
who changed what and when in <file>
$ git blame <file>

4.branches & tags
List all branches and last commit information
$ git branch -av
switch head branch
$ git checkout <branch>
create a new branch based on your current HEAD
$ git branch <new-branch>
create a new tracking branch based on a remote branch
$ git checkout --track <remote/branch>
delete a local branch
$ git branch -d <branch>
mark the current commit with a tag
$ git tag <tag-name>

5.update &  publish
list all currently configured remotes
$ git remote -v
show information about a remote
$ git remote show <remote>
add new remote repository ,named <remote>
$ git remote add <remote> <url>
download all changes from <remote>,but don't integrate into head
$ git fetch <remote>
download changes and directly merge/integrate into HEAD
$ git pull <remote> <branch>
publish local changes on a remote
$ git push <remote> <branch>
delete a remote branch on the remote
$ git branch -dr <remote/branch>
publish you tags
$ git push --tags

6.merge & rebase
merge<branch> into your current HEAD
$ git merge <branch>
rebase your current HEAD onto <branch>
$ gitrebase --abort
continue a rebase after resolving conflicts
$ git mergetool
use your editor to manually solve conflicts and (after resolving) mark file as resolved
$ git add <resolved-file>
$ git rm <resolved-file>

7.undo
discard all local changes in your working directory
$ git reset -- hard HEAD
discard local changes in a specific file
$ git checkout HEAD <file>
revert a commit (by producing a new commit with contrary changes)
$ git revert <commit>
reset your HEAD pointer to a previous commit and discard all changes since then
$ git reset --hard <commit>



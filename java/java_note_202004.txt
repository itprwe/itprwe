java ee  java se
java note
1.一个源文件中至多只能声明一个public类，其他类个数不限，且文件名必须与public类名相同
2.常用dos命令
dir 查看本目录下的文件和子目录列表
3.idea 创建java项目
4.桌球游戏
5.注释
6.变量 局部变量 成员变量 静态变量
7.for循环
8.面向对象
数据无管理时代
数组管理时代
对象
9.对象和类
内存中一堆相关联的数据
类是对象的模板（以这个模板创建对象）
类是对象的抽象（抽出类似的部分）
对象是类的实例
10.面向对象内存分析
java虚拟机的内存可以分为三个区域：
栈stack，
a.栈是方法执行的内存模型，每个方法被调用都会创建一个栈帧（存储局部变量，操作数，方法出口等）
b.jvm为每个线程创建一个栈，用于存放该线程执行方法的信息（实际参数，局部变量等）
c.栈属于线程私有，不能实现线程间的共享
d.栈的存储特性是“先进后出，后进先出”
e.栈是有系统自动分配的，速度快，栈是一个连续的内存空间
堆heap，
a.堆用于存储创建好的对象和数组（数组也是对象）
b.jvm只有一个堆，被所有的线程共享
c.堆是一个不连续的内存空间，分配灵活，速度慢
方法区（静态区）methodarea（也在堆中）
a.jvm只有一个方法区，被所有线程共享
b.方法区实际也是堆，只是用于存储类，常量相关的信息
c.用来存放程序中永远不变或者唯一的内容。（类信息【class对象】，静态变量，字符串常量等）

11.构造方法
用于对象初始化
a.通过new调用
b.构造器虽然有返回值，但是不能定义返回值类型（返回值得类型肯定是本类），不能在构造器利使用return返回某个值
c.如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数，如果已定义则编译器不会自动添加
d.构造器的方法名必须和类名一致

12.垃圾回收机制Carbage Collenction
a.java引入了垃圾回收机制
b.发现无用的对象（1.引用计数法：对象是否被引用来看对象是否使用，循环不好计算 2.引用可达法-跟搜索算法：所有引用关系做一张图，看看某个对象是否被引用）
c.回收无用对象占用的内存空间

13.分代垃圾回收机制
a.年轻代Eden:所有新生成的对象首先都是放在Eden区，年轻代目标尽可能快的收集掉那些生命周期短的对象，对应的是Minor GC，每次MinorGC会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间，当“年轻代”区域存放满对象后，就将对象存放到年老代区域。
b.年老代Tenured/old：在年轻代中经历了N(默认15次)次垃圾回收后任然存活的对象，就会被放到年老代中，因此，可以认为年老代中存放的都是一些生命周期较长的对象，年老代中的对象越来越多，我们就需要启动Major GC和Full GC,来一次大扫除，全面清理年轻代，年老代区域。
c.持久代Survivor：用于存放静态文件，如java类，方法等，持久代对垃圾回收没有显著影响
Minor GC：用于清理年轻代区域，Eden区满了就会触发一次Minor GC，清理无用对象，将有用对象复制到“Survivor1”，“Survivor2”区中（这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空）
Major GC：用于清理年老代
Full GC：用于清理年轻代，年老代，成本较高，对系统性能影响较大
垃圾回收过程
a.新创建的对象绝大多数会存储在Eden中
b.当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC）,将无用对象清理掉，然后将剩余对象复制到某个Survivor1中，同时清空Eden区
c.当Eden区再次满了，会将Survivor1中不能清空的对象移到另一个Survivor2中，同时将Eden中不能清空的对象，也复制到s1中，保证Eden和S1均被清空
d.重复多次（15）Survivor中没有被清理的对象，则会复制到老年代区中
e.当old满了，则会触发一个一次完整的垃圾回收Full GC之前新生代的垃圾回收称为MinorGC

13.jvm调优和Full GC
在jvm调优的过程中，很大一部分工作就是对于Full GC的调节，如下原因可能导致Full GC
年老代写满
持久代写满
System.out被显示调用（程序建议GC启动，不是调用GC）
上一次GC之后Heap的各域分配策略动态变化

14.对象创建过程和this的本质（指代当前对象）
a.分配对象空间，并将对象成员变量初始化为0或空
b.执行属性值得显式初始化
c.执行构造方法
d.返回对象的地址给相关变量
this本质是创建好的对象的地址，由于在构造方法调用前，对象已经存在，因此子啊构造方法中也可以使用this表示当前对象

15.static 
在类中，用static声明的成员变量为静态成员变量，也称为类变量，类变量的生命周期和类相同，在整个应用程序执行期间都有效
调用

16.静态初始化块

17.参数传值技术

18.包机制
如果遇到大量同名类，通过包容易解决类重名的问题，也可以实现对类的有效管理。包对于类相当于文件夹对于文件的作用
域名倒着写
19.jdk中主要包
java.lang 中所有的类不用导入
java.io
java.awt
java.net
java.util
20.import

21.面向对象的三大特征：继承，封装，多态；抽象类，接口，内部类

22.继承，类只有单继承，但接口可以多继承
23.方法的重写override：方法名，形参列表相同；返回值类型和声明异常类型，子类小于等于父类；访问权限子类大于等于父类。

24.object中
toStirng()重写

25.“==”比较双方是否相同，基本类型则表示值相等，引用类型表示地址相等即为同一个对象
equals 表示对象内容是否相等
开始看源码

26.super是直接父类对象的引用，可以通过super来访问父类中被子类覆盖的方法或属性

27.继承树的追溯
a.属性/方法查找顺序（如变量h）:查找当前类中有没有h，依次上溯每个父类查看父类中有没有h直到Objec，如果没有找到，则出现错误，只要找到变量则这个过程就终止、
b.构造方法调用顺序
构造方法第一句总是surper(...)来调用父类的构造方法（不论写不写会有super），流程：先向上追溯到Object,然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。
注：静态初始化块调用顺序与构造方法一样

28.封装 高内聚，低耦合，复杂性封装起来，外部调用简单。属性和方法不让其他访问防止修改
封装实现使用一些控制访问符
private 只有自己类可以访问
default 表示没有修饰符，同一个包的类可以看见
protect 同一个包类及其他包的子类访问
public 被该项目的所有包中的类访问	

29.封装使用细节
什么时候用哪一个访问修饰符
类的属性处理
a.一般使用private访问权限
b.提供相应的get/set方法访问相关属性，这些方法通常是public修饰的，已提供对属性的赋值或读取操作（boolean方法的get方法是is开头）-javabean
c.一些只用于本类的辅佐性方法可以用private修饰，希望其他类调用的方法用public

30.多态
同一个方法调用，由于对象不同可能会有不同的行为，现实生活中，同一个方法，具体实现会完全不同
a.多态是方法的多态，不是属性的多态（多态与属性无关）
b.多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象（就是把子类传给父类，但是返回的是子类的方法）
c.父类引用指向子类对象后，用该父类引用调用子类重写的方法，返回的是子类的方法中的内容，此时多态就出现了
31.对象的转型
父类引用子类指向子类，称为向上转型，子类自动转为父类（Animal d = new  Dog();），属于自动类型转换
向上转型后的父类引用变量只能调用他编译类型的方法，不能调用它运行时候类型的方法。强制转型就是向下转型（父类转为子类Dog d2 = (Dog)d;）

32.final关键字
a.修饰变量，修饰的变量不可改变，一旦赋值就不能重新赋值
b.修饰方法，该方法不可被子类重写，但是可以被重载（方法名相同，但参数不同）
c.修饰类，则该类不能被继承

33.抽象类，抽象方法

34.接口
不提供任何实现，里面所有的方法都是抽象方法
只定义规范，实现规范和具体的分离
接口可以继承多个父类
接口里面只定义常量，方法 且是public
实现类可以实现多个父接口
面向接口编程

35.内部内概念
一个类放在另一个类的内部就是内部类innerclass
内部类可以使用public,default，protect，private以及static修饰，而外部顶级类只能用public和default修改
内部类只是一个编译时的概念，一旦我们编译成功，就会成为完全不同的两个类。编译完成后出现Outer.class和Out$Inner.class两个类的字节码文件，其成员变量/方法名可以和外部类的相同。
内部类作用：
1. 内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。
2. 内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。
3. 接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完整。

内部类的使用场合：
1. 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。
2. 使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响。

36.内部类的分类
成员内部类(非静态内部类、静态内部类)、匿名内部类、局部内部类。
成员内部类可以使用任意限制修饰符
a.非静态内部类（外部内里使用非静态内部类和平时使用其他类没有什么不同）
1）非静态内部类必须寄存在一个外部类对象里，因此，如果有一个非静态内部类对象，那么一定存在对应的外部类对象，非静态内部类对象单独属于外部类的某个对象。
2）非静态内部咧可以直接访问外部内成员，但是外部类不能直接访问非静态内部类成员。
3）非静态内部类不能有静态方法，静态属性和静态初始化块
4）外部类的静态方法，静态代码块不能访问非静态内部类，包括不能使用非静态内部类定义变量、创建实例


37.String
不可变字符序列
字符串常量会放到常量池
1）每个用双引号的字符串都是String类的一个实例
+号运算符的两边只要有一个是字符串，则自动会将另一个转为字符串
2）String类和常量池
a.全局字符串常量池（String Pool）
全局字符串常量池中存放的内容是在类加载完成后存到String Pool中的，在每个VM中只有一份，存放的是字符串常量的引用值（在堆中生成字符串对象实例）
b.class文件常量池（Class Constant Pool）
class常量池是在编译的时候每个class都有的，在编译阶段，存放的是常量（文本字符串，final常量等）和符号引用
c.运行时常量池（Runtime Constant Pool）
运行时常量池是在类加载完成之后，将每个class常量池中的符号引用值转存到运行时常量池中，每个class都有一个运行时常量池，类在解析后，将符号引用替换为直接引用，与全局常量池中的引用保持一致

38.开闭原则

39.异常
Throwable
--Error 程序无法处理的错误，JVM运行时出现的错误
--Exception 程序本身能够处理的异常，（NullPointerException，ClassCastException，ArrayIndexOutOfBoundsException，ArithmeticException）
异常分为：
RuntimeException 
CheckedException  这类异常在编译时就必须做出处理，否则无法通过编译。try catch 或者 declaration
异常处理方法：
a.try-catch-finally（不论是否有异常finally都会执行）
catch异常子类在前，父类在后
b.throws谁调用我谁处理异常（异常由最高层处理）
自定义异常

40.数组（也是对象）
相同类型数据的有序集合
数组长度确定
元素类型相同
可以是任何类型
a.//声明数组，指定长度（栈内变量，在堆内分配空间），初始化

数组赋值、
foreach循环

41.数组的拷贝
arraycopy
删除一个元素
数组扩容
插入一个元素

42.工具类java.util.Arrays使用

43.数组存储表格数据
冒泡
二分法

44.包装类
基本数据类型不是对象，转为包装类作为对象使用
byte Byte;boolean Boolean;short Short;char Character；int Integer;long Long;float Float;double Double
Integer 基本类型 字符串 包装类相互转换

45.自动装箱(Integer.valueOf(111))，自动拆箱（a.intValue()） 编译器处理
缓存

46.String类

47.StringBuilder线程不安全 StringBuffer线程安全 --可变字符序列，数组中的内容可以随意修改
String与StringBuilder效率对比

48.时间处理类
Date d = new Date(2000);
日期处理使用Calendar

49.DateFormat抽象类（不能被new，new其实现类）和SimpleDateFormat实现类的使用
DateFormat字符串解析为时间parse（）  时间解析为字符串format（）

50.Calendar类

51.Math Random

52.File类 文件文件目录 增删改查文件
递归便利目录结构和树状展现
递归：递归头（什么时候不调用自己），递归体（什么时候调用自己）
if(n==1){return 1}else{ return n*function(n-1)}

53.枚举 enum

54.容器
数组也是一种容器，可以在其中放置对象或基本数据类型，优点，是一种简单的线性序列，可以快速的访问数组元素，效率高。如果从效率和类型检查来讲，数组是最好的。
缺点，不灵活，容量需要事先定义好，不能随着需求的变化而扩容。
Collenction
-Set
--HashSet
-List
--ArrayList
--LinkList
Map
-HashMap
55.泛型是jdk1.5后增加的，它可以帮助我们建立类型安全的集合
泛型本质：就是数据类型的参数化，数据类型的一个占位符（形式参数），即告诉编译器，在调用泛型的时候必须传入实际类型

56.ArryList LinkList源码学习
transient关键字

57.Vector线程安全，效率低

58.Map存储键值对，键不能重复（根据equals判断），重复了则后面的会覆盖前面的值

59.HashMap底层实现采用了哈希表，这是一种非常重要的数据结构（reids），看源码
基本结构：数组+链表
存储过程：
key对象+value对象-->获取key对象的hashcode()-->hashcode哈希码
HashMap的hash()方法计算出[0,table数组length-1]的数-->计算出hash值
hash:15,key对象,value对象,next:null
根据hash为15将entry对象存储到数组索引位置
JDK8中，当链表长度大于8时，链表就转换为红黑树，这样又大大提高了查找的效率

get取值过程
get()的时候计算出hashcode然后通过与HashMap的hash()方法得出hash值（对应列表的哪一行），
找到后然后通过equals方法比较那一列中的所有key相同的话就取出value

二叉树和红黑二叉树原理

60.TreeMap排序的时候用，底层用红黑二叉树实现原理？
61.HashTable线程安全，效率低，不允许key或value为null;HashMap线程不安全，效率高，运行key或value为null;

61.Set接口没有顺序，不可重复
HashSet
TreeSet

62.Iterator  

63.ORM思想 
将表格数据每行存到map中，最后map存到list中
每一行数据用一个javabean对象存储，然后所有数据存到map或list中
jdbc把表数据放对象中，把对象存到表中


总结：
语言基础
oop
容器 手写容器

1.IO
api
任何类都有构造器

io 
枚举类型 
注解 
并发 
图形化
多线程 
网络编程 
反射 
jdbc 
MySQL












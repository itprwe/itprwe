java note
1.一个源文件中至多只能声明一个public类，其他类个数不限，且文件名必须与public类名相同
2.常用dos命令
dir 查看本目录下的文件和子目录列表
3.idea 创建java项目
4.桌球游戏
5.注释
6.变量 局部变量 成员变量 静态变量
7.for循环
8.面向对象
数据无管理时代
数组管理时代
对象
9.对象和类
内存中一堆相关联的数据
类是对象的模板（以这个模板创建对象）
类是对象的抽象（抽出类似的部分）
对象是类的实例
10.面向对象内存分析
java虚拟机的内存可以分为三个区域：
栈stack，
a.栈是方法执行的内存模型，每个方法被调用都会创建一个栈帧（存储局部变量，操作数，方法出口等）
b.jvm为每个线程创建一个栈，用于存放该线程执行方法的信息（实际参数，局部变量等）
c.栈属于线程私有，不能实现线程间的共享
d.栈的存储特性是“先进后出，后进先出”
e.栈是有系统自动分配的，速度快，栈是一个连续的内存空间
堆heap，
a.堆用于存储创建好的对象和数组（数组也是对象）
b.jvm只有一个堆，被所有的线程共享
c.堆是一个不连续的内存空间，分配灵活，速度慢
方法区（静态区）methodarea（也在堆中）
a.jvm只有一个方法区，被所有线程共享
b.方法区实际也是堆，只是用于存储类，常量相关的信息
c.用来存放程序中永远不变或者唯一的内容。（类信息【class对象】，静态变量，字符串常量等）

11.构造方法
用于对象初始化
a.通过new调用
b.构造器虽然有返回值，但是不能定义返回值类型（返回值得类型肯定是本类），不能在构造器利使用return返回某个值
c.如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数，如果已定义则编译器不会自动添加
d.构造器的方法名必须和类名一致

12.垃圾回收机制Carbage Collenction
a.java引入了垃圾回收机制
b.发现无用的对象（1.引用计数法：对象是否被引用来看对象是否使用，循环不好计算 2.引用可达法-跟搜索算法：所有引用关系做一张图，看看某个对象是否被引用）
c.回收无用对象占用的内存空间

13.分代垃圾回收机制
a.年轻代Eden:所有新生成的对象首先都是放在Eden区，年轻代目标尽可能快的收集掉那些生命周期短的对象，对应的是Minor GC，每次MinorGC会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间，当“年轻代”区域存放满对象后，就将对象存放到年老代区域。
b.年老代Tenured/old：在年轻代中经历了N(默认15次)次垃圾回收后任然存活的对象，就会被放到年老代中，因此，可以认为年老代中存放的都是一些生命周期较长的对象，年老代中的对象越来越多，我们就需要启动Major GC和Full GC,来一次大扫除，全面清理年轻代，年老代区域。
c.持久代Survivor：用于存放静态文件，如java类，方法等，持久代对垃圾回收没有显著影响
Minor GC：用于清理年轻代区域，Eden区满了就会触发一次Minor GC，清理无用对象，将有用对象复制到“Survivor1”，“Survivor2”区中（这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空）
Major GC：用于清理年老代
Full GC：用于清理年轻代，年老代，成本较高，对系统性能影响较大
垃圾回收过程
a.新创建的对象绝大多数会存储在Eden中
b.当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC）,将无用对象清理掉，然后将剩余对象复制到某个Survivor1中，同时清空Eden区
c.当Eden区再次满了，会将Survivor1中不能清空的对象移到另一个Survivor2中，同时将Eden中不能清空的对象，也复制到s1中，保证Eden和S1均被清空
d.重复多次（15）Survivor中没有被清理的对象，则会复制到老年代区中
e.当old满了，则会触发一个一次完整的垃圾回收Full GC之前新生代的垃圾回收称为MinorGC

13.jvm调优和Full GC
在jvm调优的过程中，很大一部分工作就是对于Full GC的调节，如下原因可能导致Full GC
年老代写满
持久代写满
System.out被显示调用（程序建议GC启动，不是调用GC）
上一次GC之后Heap的各域分配策略动态变化

14.对象创建过程和this的本质（指代当前对象）
a.分配对象空间，并将对象成员变量初始化为0或空
b.执行属性值得显式初始化
c.执行构造方法
d.返回对象的地址给相关变量
this本质是创建好的对象的地址，由于在构造方法调用前，对象已经存在，因此子啊构造方法中也可以使用this表示当前对象

15.static

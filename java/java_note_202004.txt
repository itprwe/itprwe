java ee  java se
java note
1.一个源文件中至多只能声明一个public类，其他类个数不限，且文件名必须与public类名相同
2.常用dos命令
dir 查看本目录下的文件和子目录列表
3.idea 创建java项目
4.桌球游戏
5.注释
6.变量 局部变量 成员变量 静态变量
7.for循环
8.面向对象
数据无管理时代
数组管理时代
对象
9.对象和类
内存中一堆相关联的数据
类是对象的模板（以这个模板创建对象）
类是对象的抽象（抽出类似的部分）
对象是类的实例
10.面向对象内存分析
java虚拟机的内存可以分为三个区域：
栈stack，
a.栈是方法执行的内存模型，每个方法被调用都会创建一个栈帧（存储局部变量，操作数，方法出口等）
b.jvm为每个线程创建一个栈，用于存放该线程执行方法的信息（实际参数，局部变量等）
c.栈属于线程私有，不能实现线程间的共享
d.栈的存储特性是“先进后出，后进先出”
e.栈是有系统自动分配的，速度快，栈是一个连续的内存空间
堆heap，
a.堆用于存储创建好的对象和数组（数组也是对象）
b.jvm只有一个堆，被所有的线程共享
c.堆是一个不连续的内存空间，分配灵活，速度慢
方法区（静态区）methodarea（也在堆中）
a.jvm只有一个方法区，被所有线程共享
b.方法区实际也是堆，只是用于存储类，常量相关的信息
c.用来存放程序中永远不变或者唯一的内容。（类信息【class对象】，静态变量，字符串常量等）

11.构造方法
用于对象初始化
a.通过new调用
b.构造器虽然有返回值，但是不能定义返回值类型（返回值得类型肯定是本类），不能在构造器利使用return返回某个值
c.如果我们没有定义构造器，则编译器会自动定义一个无参的构造函数，如果已定义则编译器不会自动添加
d.构造器的方法名必须和类名一致

12.垃圾回收机制Carbage Collenction
a.java引入了垃圾回收机制
b.发现无用的对象（1.引用计数法：对象是否被引用来看对象是否使用，循环不好计算 2.引用可达法-跟搜索算法：所有引用关系做一张图，看看某个对象是否被引用）
c.回收无用对象占用的内存空间

13.分代垃圾回收机制
a.年轻代Eden:所有新生成的对象首先都是放在Eden区，年轻代目标尽可能快的收集掉那些生命周期短的对象，对应的是Minor GC，每次MinorGC会清理年轻代的内存，算法采用效率较高的复制算法，频繁的操作，但是会浪费内存空间，当“年轻代”区域存放满对象后，就将对象存放到年老代区域。
b.年老代Tenured/old：在年轻代中经历了N(默认15次)次垃圾回收后任然存活的对象，就会被放到年老代中，因此，可以认为年老代中存放的都是一些生命周期较长的对象，年老代中的对象越来越多，我们就需要启动Major GC和Full GC,来一次大扫除，全面清理年轻代，年老代区域。
c.持久代Survivor：用于存放静态文件，如java类，方法等，持久代对垃圾回收没有显著影响
Minor GC：用于清理年轻代区域，Eden区满了就会触发一次Minor GC，清理无用对象，将有用对象复制到“Survivor1”，“Survivor2”区中（这两个区，大小空间也相同，同一时刻Survivor1和Survivor2只有一个在用，一个为空）
Major GC：用于清理年老代
Full GC：用于清理年轻代，年老代，成本较高，对系统性能影响较大
垃圾回收过程
a.新创建的对象绝大多数会存储在Eden中
b.当Eden满了（达到一定比例）不能创建新对象，则触发垃圾回收（GC）,将无用对象清理掉，然后将剩余对象复制到某个Survivor1中，同时清空Eden区
c.当Eden区再次满了，会将Survivor1中不能清空的对象移到另一个Survivor2中，同时将Eden中不能清空的对象，也复制到s1中，保证Eden和S1均被清空
d.重复多次（15）Survivor中没有被清理的对象，则会复制到老年代区中
e.当old满了，则会触发一个一次完整的垃圾回收Full GC之前新生代的垃圾回收称为MinorGC

13.jvm调优和Full GC
在jvm调优的过程中，很大一部分工作就是对于Full GC的调节，如下原因可能导致Full GC
年老代写满
持久代写满
System.out被显示调用（程序建议GC启动，不是调用GC）
上一次GC之后Heap的各域分配策略动态变化

14.对象创建过程和this的本质（指代当前对象）
a.分配对象空间，并将对象成员变量初始化为0或空
b.执行属性值得显式初始化
c.执行构造方法
d.返回对象的地址给相关变量
this本质是创建好的对象的地址，由于在构造方法调用前，对象已经存在，因此子啊构造方法中也可以使用this表示当前对象

15.static 
在类中，用static声明的成员变量为静态成员变量，也称为类变量，类变量的生命周期和类相同，在整个应用程序执行期间都有效
调用

16.静态初始化块

17.参数传值技术

18.包机制
如果遇到大量同名类，通过包容易解决类重名的问题，也可以实现对类的有效管理。包对于类相当于文件夹对于文件的作用
域名倒着写
19.jdk中主要包
java.lang 中所有的类不用导入
java.io
java.awt
java.net
java.util
20.import

21.面向对象的三大特征：继承，封装，多态；抽象类，接口，内部类

22.继承，类只有单继承，但接口可以多继承
23.方法的重写override：方法名，形参列表相同；返回值类型和声明异常类型，子类小于等于父类；访问权限子类大于等于父类。

24.object中
toStirng()重写

25.“==”比较双方是否相同，基本类型则表示值相等，引用类型表示地址相等即为同一个对象
equals 表示对象内容是否相等
开始看源码

26.super是直接父类对象的引用，可以通过super来访问父类中被子类覆盖的方法或属性

27.继承树的追溯
a.属性/方法查找顺序（如变量h）:查找当前类中有没有h，依次上溯每个父类查看父类中有没有h直到Objec，如果没有找到，则出现错误，只要找到变量则这个过程就终止、
b.构造方法调用顺序
构造方法第一句总是surper(...)来调用父类的构造方法（不论写不写会有super），流程：先向上追溯到Object,然后再依次向下执行类的初始化块和构造方法，直到当前子类为止。
注：静态初始化块调用顺序与构造方法一样

28.封装 高内聚，低耦合，复杂性封装起来，外部调用简单。属性和方法不让其他访问防止修改
封装实现使用一些控制访问符
private 只有自己类可以访问
default 表示没有修饰符，同一个包的类可以看见
protect 同一个包类及其他包的子类访问
public 被该项目的所有包中的类访问	

29.封装使用细节
什么时候用哪一个访问修饰符
类的属性处理
a.一般使用private访问权限
b.提供相应的get/set方法访问相关属性，这些方法通常是public修饰的，已提供对属性的赋值或读取操作（boolean方法的get方法是is开头）-javabean
c.一些只用于本类的辅佐性方法可以用private修饰，希望其他类调用的方法用public

30.多态
同一个方法调用，由于对象不同可能会有不同的行为，现实生活中，同一个方法，具体实现会完全不同
a.多态是方法的多态，不是属性的多态（多态与属性无关）
b.多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象（就是把子类传给父类，但是返回的是子类的方法）
c.父类引用指向子类对象后，用该父类引用调用子类重写的方法，返回的是子类的方法中的内容，此时多态就出现了
31.对象的转型
父类引用子类指向子类，称为向上转型，子类自动转为父类（Animal d = new  Dog();），属于自动类型转换
向上转型后的父类引用变量只能调用他编译类型的方法，不能调用它运行时候类型的方法。强制转型就是向下转型（父类转为子类Dog d2 = (Dog)d;）

32.final关键字




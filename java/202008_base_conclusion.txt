Alt+Insert，可以生成构造器/Getter/Setter等
Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义
Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch
Alt+Enter， 自动修正
Ctrl+Alt+L，格式化代码
Ctrl+Alt+O 导入包
Ctrl+J，自动代码联想（例如：serr）

一. jvm/jre/jdk/类型转换/switch/for/break/contiune/方法重载/递归
1.jvm/jre/jdk
jvm:java virtual machine
只认识.class文件，将文件中的字节码指令进行识别并调用操作系统向上的API完成动作。jvm是java能跨平台的核心
jre:java runtime environment
包含两个部分，jvm的标准实现和java的一些基本类库
jdk:java development kit
java开发工具包，是整个java开发的核心，集成了jre和一下好用的小工具（javac.exe,java.exe,jar.exe）
真正在运行java时起作用的 bin、include、lib、 jre
JDK>JRE>JVM
JRE = JVM + libraries to run Java Application
JDK = JRE + tools to develop Java Application
https://blog.csdn.net/weixin_38339025/article/details/90313695

2.jvm体系结构：
JVM 主要分为三个子系统：
1)类加载器：
a.Loading - 加载
Bootstrap ClassLoader - 加载 rt.jar 核心类库，是优先级最高的加载器
Extension ClassLoader - 负责加载 jre\lib\ext 文件夹中的类
Application ClassLoader -负责加载 CLASSPATH 指定的类库
b.Linking - 链接
Verify - 验证：验证生成的字节码是否正确
Prepare - 准备：为所有静态变量，分配内存并赋予默认值
Resolve - 解析：将 class 文件常量池中所有对内存的符号引用，替换成到方法区的直接引用
c.Initialization - 类初始化
类加载的最后阶段，这里对静态变量进行赋值，并执行静态块。（注意区分对象初始化）
2)运行时数据区Runtime Data Areas:
a.Method Area- 方法区
也被称为元空间，还有个别名 non-heap（非堆），使用本地内存存储 class meta-data 元数据（运行时常量池，字段和方法的数据，构造函数和方法的字节码等），在 JDK 8 中，把 interned String 和类静态变量移动到了 Java 堆
b.Heap Area - 堆 
存储类实例对象和数组对象，垃圾回收的主要区域
c.Stack Area - 栈
在方法调用时，创建一个叫栈帧的数据结构，用于存储局部变量和部分过程的结果，栈帧由以下几部分组成：
局部变量表：存储方法调用时传递的参数，从0开始存储this、方法参数、局部变量
操作数栈：执行中间操作，存储从局部变量表或对象实例字段复制的常量或变量值，以及操作结果，另外，还用来准备被调用方法的参数和接受方法调用的返回结果
动态链接：一个指向运行时常量池的引用，将 class 文件中的符号引用（描述一个方法调用了其他方法或访问成员变量）转为直接引用
方法返回地址：方法正常退出或抛出异常退出，返回方法被调用的位置
d.Pc Registers - 寄存器（程序计数器）
保存正在执行的字节码指令的地址
e.RuntimeConstant Pool -运行时常量池（方法区的一部分）
存储类或接口中的数值字面量，字符串字面量以及所有方法或字段的引用，基本上涉及到方法或字段，JVM 就会在运行时常量池中搜索其具体的内存地址
f.Native Method Stacks
JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态

3)执行引擎

java内存模型
java对象模型
https://www.cnblogs.com/chuonye/p/11349042.html

2.类型转换/switch/for/break/contiune
1)类型转换
自动转换/强制转换
2)switch
基本数据类型：byte, short, char, int
包装数据类型：Byte, Short, Character, Integer
枚举类型：Enum
字符串类型：String（Jdk 7+ 开始支持）
switch lamda表达式
 
 for/break/contiune，foreach lamda 对于耗时的操作用lambda表达式的for循环，如数据库的IO操作，多线程充分利用CPU资源；对于不太耗时的操作使用普通for循环，比如纯CPU计算类型的操作，单线程性能更高，减少上下文切换的开销
 
 流(Stream)或并行流(parallelStream)
 
 stream与lamda表达式

 3.方法重载/递归
在同一个类中， 允许存在一个以上的同名方法， 只要它们
的参数个数或者参数类型不同即可。
– 与返回值类型无关， 只看方法名和参数列表
– 在调用时， 虚拟机通过参数列表的不同来区分同名方法

递归
自己调用自己，有递归头：什么时候结束递归；递归体：什么时候调用自己

二. 封装继承多态
1）对象和类的概念
抽象就是抽出像的部分归为一类
类为class：对对象的抽象，同一类型对象的一个抽象概念，定义了这类对象所应该具有的共有属性，方法，看做一类对象的模板
对象Object/实例：具体的事物，看做类的一个实际例子

一个类中三种常见的成员：
属性field 或者叫成员变量
方法method
构造器constructor，返回一个类的对象且初始化对象
避免忘记初始化！！对象属性初始化以后，这个对象里面的属性就有值了，可以被使用

一个类中可以有多个class，但是只能有一个public类

垃圾回收机制
内存泄漏原因

2) this关键字
只能在构造方法中用，并且必须位于构造方法的第一句
this不能用于static方法中
对象创建的过程和this的本质
　　构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步：
　　1. 分配对象空间，并将对象成员变量初始化为0或空
　　2. 执行属性值的显示初始化
　　3. 执行构造方法
　　4. 返回对象的地址给相关的变量
　　this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象”

3) static关键字
A 类中static声明的成员变量为静态成员变量，也称为类变量， 类变量的生命周期和类相同，在整个应用程序执行期间都有效
	1. 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。
	2. 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!!
	3. 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。)
	4. 在static方法中不可直接访问非static的成员。

B 核心要点：
    static修饰的成员变量和方法，从属于类。
    普通变量和方法从属于对象的
	
C  static 静态块
构造方法用于对象的初始化!静态初始化块，用于类的初始化操作!在静态初始化块中不能直接访问非static成员
注意事项：
　　静态初始化块执行顺序(学完继承再看这里)：
　　1. 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。
　　2. 构造方法执行顺序和上面顺序一样!!	

4） 继承 extends
类继承父类的特征和行为，父类的private方法和属性不能继承
只支持单继承
子类可以拥有父类，自己的属性方法，子类可以重写覆盖父类方法
A，在父子类关系继承中，如果成员变量重名，则创建子类对象时，访问有两种方式。
a，直接通过子类对象访问成员变量
​ 等号左边是谁，就优先使用谁，如果没有就向上找。
b，间接通过成员方法访问成员变量
该方法属于谁，谁就优先使用，如果没有就向上找。

B，成员方法也是一样的，创建的对象是谁，就优先使用谁，如果没有则直接向上找。
​ 注意事项：
​ 无论是成员变量还是成员方法，如果没有都是向上父类中查找，绝对不会向下查找子类的
C，在继承关系中，关于成员变量的使用：
​ 局部成员变量：直接使用
​ 本类成员变量：this.成员变量
​ 父类成员变量：super.父类成员变量

D . 继承树追溯，调用顺序，不是初始化顺序
属性/方法查找顺序：(比如：查找变量h)
---查找当前类中有没有属性h
---依次上溯每个父类，查看每个父类中是否有h，直到Object
---如果没找到，则出现编译错误。
---上面步骤，只要找到h变量，则这个过程终止
构造方法调用顺序
----构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止；
静态初始化块调用顺序
----与构造方法调用顺序一样；

E . 初始化顺序
父类静态块，子类静态块，且只运行一次
父类属性变量，子类属性变量
父类构造方法，子类构造方法

5）方法重写
符合下面的三个要点： 
方法名、形参列表相同
返回值类型和声明异常类型，子类小于等于父类
访问权限，子类大于等于父类

6）toString()
* System.out.println(ts)=System.out.println(ts.toString())
* 打印方法实际调用了toString()方法

7）==和equals方法

8）super关键字
uper是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性
使用super调用普通方法，语句没有位置限制，可以在子类中随便调用

9）封装
A . 需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。
封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节
B . 编程中封装的具体优点：
提高代码的安全性。
提高代码的复用性。
“高内聚”：封装细节，便于修改内部代码，提高可维护性。
“低耦合”：简化外部调用，便于调用者使用，便于扩展和协作
C . 封装的使用：
使用private修饰符，表示最小的访问权限。
对成员变量的访问，统一提供setXXX，getXXX方法

D .  封装的实现—使用访问控制符
public 项目的所有包中的所有类
protect 同一个包的类以及其他包中的子类
default  表示没有修饰符修饰，只有同一个包的类能访问
private 表示私有，只有自己类能访问

E . 封装的使用细节
类的属性的处理:
. 一般使用private访问权限。
.  提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。
. 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰


Alt+Insert，可以生成构造器/Getter/Setter等
Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义
Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catch
Alt+Enter， 自动修正
Ctrl+Alt+L，格式化代码
Ctrl+Alt+O 导入包
Ctrl+J，自动代码联想（例如：serr）

一. jvm/jre/jdk/类型转换/switch/for/break/contiune/方法重载/递归
1.jvm/jre/jdk
jvm:java virtual machine
只认识.class文件，将文件中的字节码指令进行识别并调用操作系统向上的API完成动作。jvm是java能跨平台的核心
jre:java runtime environment
包含两个部分，jvm的标准实现和java的一些基本类库
jdk:java development kit
java开发工具包，是整个java开发的核心，集成了jre和一下好用的小工具（javac.exe,java.exe,jar.exe）
真正在运行java时起作用的 bin、include、lib、 jre
JDK>JRE>JVM
JRE = JVM + libraries to run Java Application
JDK = JRE + tools to develop Java Application
https://blog.csdn.net/weixin_38339025/article/details/90313695

2.jvm体系结构：
JVM 主要分为三个子系统：
1)类加载器：
a.Loading - 加载
Bootstrap ClassLoader - 加载 rt.jar 核心类库，是优先级最高的加载器
Extension ClassLoader - 负责加载 jre\lib\ext 文件夹中的类
Application ClassLoader -负责加载 CLASSPATH 指定的类库
b.Linking - 链接
Verify - 验证：验证生成的字节码是否正确
Prepare - 准备：为所有静态变量，分配内存并赋予默认值
Resolve - 解析：将 class 文件常量池中所有对内存的符号引用，替换成到方法区的直接引用
c.Initialization - 类初始化
类加载的最后阶段，这里对静态变量进行赋值，并执行静态块。（注意区分对象初始化）
2)运行时数据区Runtime Data Areas:
a.Method Area- 方法区
也被称为元空间，还有个别名 non-heap（非堆），使用本地内存存储 class meta-data 元数据（运行时常量池，字段和方法的数据，构造函数和方法的字节码等），在 JDK 8 中，把 interned String 和类静态变量移动到了 Java 堆
b.Heap Area - 堆 
存储类实例对象和数组对象，垃圾回收的主要区域
c.Stack Area - 栈
在方法调用时，创建一个叫栈帧的数据结构，用于存储局部变量和部分过程的结果，栈帧由以下几部分组成：
局部变量表：存储方法调用时传递的参数，从0开始存储this、方法参数、局部变量
操作数栈：执行中间操作，存储从局部变量表或对象实例字段复制的常量或变量值，以及操作结果，另外，还用来准备被调用方法的参数和接受方法调用的返回结果
动态链接：一个指向运行时常量池的引用，将 class 文件中的符号引用（描述一个方法调用了其他方法或访问成员变量）转为直接引用
方法返回地址：方法正常退出或抛出异常退出，返回方法被调用的位置
d.Pc Registers - 寄存器（程序计数器）
保存正在执行的字节码指令的地址
e.RuntimeConstant Pool -运行时常量池（方法区的一部分）
存储类或接口中的数值字面量，字符串字面量以及所有方法或字段的引用，基本上涉及到方法或字段，JVM 就会在运行时常量池中搜索其具体的内存地址
f.Native Method Stacks
JVM采用本地方法堆栈来支持native方法的执行，此区域用于存储每个native方法调用的状态

3)执行引擎

java内存模型
java对象模型
https://www.cnblogs.com/chuonye/p/11349042.html

2.类型转换/switch/for/break/contiune
1)类型转换
自动转换/强制转换
2)switch
基本数据类型：byte, short, char, int
包装数据类型：Byte, Short, Character, Integer
枚举类型：Enum
字符串类型：String（Jdk 7+ 开始支持）
switch lamda表达式
 
 for/break/contiune，foreach lamda 对于耗时的操作用lambda表达式的for循环，如数据库的IO操作，多线程充分利用CPU资源；对于不太耗时的操作使用普通for循环，比如纯CPU计算类型的操作，单线程性能更高，减少上下文切换的开销
 
 流(Stream)或并行流(parallelStream)
 
 stream与lamda表达式

 3.方法重载/递归
在同一个类中， 允许存在一个以上的同名方法， 只要它们
的参数个数或者参数类型不同即可。
– 与返回值类型无关， 只看方法名和参数列表
– 在调用时， 虚拟机通过参数列表的不同来区分同名方法

递归
自己调用自己，有递归头：什么时候结束递归；递归体：什么时候调用自己

二. 封装继承多态
1）对象和类的概念
抽象就是抽出像的部分归为一类
类为class：对对象的抽象，同一类型对象的一个抽象概念，定义了这类对象所应该具有的共有属性，方法，看做一类对象的模板
对象Object/实例：具体的事物，看做类的一个实际例子

一个类中三种常见的成员：
属性field 或者叫成员变量
方法method
构造器constructor，返回一个类的对象且初始化对象
避免忘记初始化！！对象属性初始化以后，这个对象里面的属性就有值了，可以被使用

一个类中可以有多个class，但是只能有一个public类

垃圾回收机制
内存泄漏原因

2) this关键字
只能在构造方法中用，并且必须位于构造方法的第一句
this不能用于static方法中
对象创建的过程和this的本质
　　构造方法是创建Java对象的重要途径，通过new关键字调用构造器时，构造器也确实返回该类的对象，但这个对象并不是完全由构造器负责创建。创建一个对象分为如下四步：
　　1. 分配对象空间，并将对象成员变量初始化为0或空
　　2. 执行属性值的显示初始化
　　3. 执行构造方法
　　4. 返回对象的地址给相关的变量
　　this的本质就是“创建好的对象的地址”! 由于在构造方法调用前，对象已经创建。因此，在构造方法中也可以使用this代表“当前对象”

3) static关键字
A 类中static声明的成员变量为静态成员变量，也称为类变量， 类变量的生命周期和类相同，在整个应用程序执行期间都有效
	1. 为该类的公用变量，属于类，被该类的所有实例共享，在类被载入时被显式初始化。
	2. 对于该类的所有对象来说，static成员变量只有一份。被该类的所有对象共享!!
	3. 一般用“类名.类属性/方法”来调用。(也可以通过对象引用或类名(不需要实例化)访问静态成员。)
	4. 在static方法中不可直接访问非static的成员。

B 核心要点：
    static修饰的成员变量和方法，从属于类。
    普通变量和方法从属于对象的
	
C  static 静态块
构造方法用于对象的初始化!静态初始化块，用于类的初始化操作!在静态初始化块中不能直接访问非static成员
注意事项：
　　静态初始化块执行顺序(学完继承再看这里)：
　　1. 上溯到Object类，先执行Object的静态初始化块，再向下执行子类的静态初始化块，直到我们的类的静态初始化块为止。
　　2. 构造方法执行顺序和上面顺序一样!!	

4） 继承 extends
类继承父类的特征和行为，父类的private方法和属性不能继承
只支持单继承
子类可以拥有父类，自己的属性方法，子类可以重写覆盖父类方法
A，在父子类关系继承中，如果成员变量重名，则创建子类对象时，访问有两种方式。
a，直接通过子类对象访问成员变量
​ 等号左边是谁，就优先使用谁，如果没有就向上找。
b，间接通过成员方法访问成员变量
该方法属于谁，谁就优先使用，如果没有就向上找。

B，成员方法也是一样的，创建的对象是谁，就优先使用谁，如果没有则直接向上找。
​ 注意事项：
​ 无论是成员变量还是成员方法，如果没有都是向上父类中查找，绝对不会向下查找子类的
C，在继承关系中，关于成员变量的使用：
​ 局部成员变量：直接使用
​ 本类成员变量：this.成员变量
​ 父类成员变量：super.父类成员变量

D . 继承树追溯，调用顺序，不是初始化顺序
属性/方法查找顺序：(比如：查找变量h)
---查找当前类中有没有属性h
---依次上溯每个父类，查看每个父类中是否有h，直到Object
---如果没找到，则出现编译错误。
---上面步骤，只要找到h变量，则这个过程终止
构造方法调用顺序
----构造方法第一句总是：super(…)来调用父类对应的构造方法。所以，流程就是：先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止；
静态初始化块调用顺序
----与构造方法调用顺序一样；

E . 初始化顺序
父类静态块，子类静态块，且只运行一次
父类属性变量，子类属性变量
父类构造方法，子类构造方法

5）方法重写
符合下面的三个要点： 
方法名、形参列表相同
返回值类型和声明异常类型，子类小于等于父类
访问权限，子类大于等于父类

6）toString()
* System.out.println(ts)=System.out.println(ts.toString())
* 打印方法实际调用了toString()方法

7）==和equals方法

8）super关键字
uper是直接父类对象的引用。可以通过super来访问父类中被子类覆盖的方法或属性
使用super调用普通方法，语句没有位置限制，可以在子类中随便调用

9）封装
A . 需要让用户知道的才暴露出来，不需要让用户知道的全部隐藏起来，这就是封装。
封装就是把对象的属性和操作结合为一个独立的整体，并尽可能隐藏对象的内部实现细节
B . 编程中封装的具体优点：
提高代码的安全性。
提高代码的复用性。
“高内聚”：封装细节，便于修改内部代码，提高可维护性。
“低耦合”：简化外部调用，便于调用者使用，便于扩展和协作
C . 封装的使用：
使用private修饰符，表示最小的访问权限。
对成员变量的访问，统一提供setXXX，getXXX方法

D .  封装的实现—使用访问控制符
public 项目的所有包中的所有类
protect 同一个包的类以及其他包中的子类
default  表示没有修饰符修饰，只有同一个包的类能访问
private 表示私有，只有自己类能访问

E . 封装的使用细节
类的属性的处理:
. 一般使用private访问权限。
.  提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作(注意：boolean变量的get方法是is开头!)。
. 一些只用于本类的辅助性方法可以用private修饰，希望其他类调用的方法用public修饰


10) 多态
 多态指的是同一个方法调用，由于对象不同可能会有不同的行为
 多态要点：
1. 多态是方法的多态，不是属性的多态(多态与属性无关)。
2. 多态的存在要有3个必要条件：继承，方法重写，父类引用指向子类对象。
3. 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了

向上转型：父类引用指向子类对象，这个过程为向上转型，属于自动类型转换
向下转型：向上转型后的父类引用变量只能调用它编译类型的方法（父类方法），不能调用它运行时类型的方法（子类特有方法）。这时，我们就需要进行类型的强制转换（再转为子类），我们称之为向下转型

 注意：在多态中，编译看左边，运行看右边
 
 11） final
 修饰变量: 被他修饰的变量不可改变。一旦赋了初值，就不能被重新赋值
 修饰方法：该方法不可被子类重写。但是可以被重载
 修饰类: 修饰的类不能被继承。比如：Math、String等

12） 抽象方法和抽象类
 抽象方法： 使用abstract修饰的方法，没有方法体，只有声明。定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现
 抽象类： 包含抽象方法的类就是抽象类。通过abstract方法定义规范，然后要求子类必须定义具体实现。通过抽象类，我们就可以做到严格限制子类的设计，使子类之间更加通用
 抽象类的使用要点:
1. 有抽象方法的类只能定义成抽象类
2. 抽象类不能实例化，即不能用new来实例化抽象类。
3. 抽象类可以包含属性、方法、构造方法。但是构造方法不能用来new实例，只能用来被子类调用。
4. 抽象类只能用来被继承。
5. 抽象方法必须被子类实现
 
 13） 接口
接口就是比“抽象类”还“抽象”的“抽象类”，可以更加规范的对子类进行约束。全面地专业地实现了：规范和具体实现的分离
抽象类还提供某些具体实现，接口不提供任何实现，接口中所有方法都是抽象方法。接口是完全面向规范的，规定了一批类具有的公共方法规范。
从接口的实现者角度看，接口定义了可以向外部提供的服务。
从接口的调用者角度看，接口定义了实现者能提供那些服务。
接口是两个模块之间通信的标准，通信的规范。如果能把你要设计的模块之间的接口定义好，就相当于完成了系统的设计大纲，剩下的就是添砖加瓦的具体实现了。大家在工作以后，做系统时往往就是使用“面向接口”的思想来设计系统。
接口和实现类不是父子关系，是实现规则的关系。比如：我定义一个接口Runnable，Car实现它就能在地上跑，Train实现它也能在地上跑，飞机实现它也能在地上跑。就是说，如果它是交通工具，就一定能跑，但是一定要实现Runnable接口
接口的本质是契约
1. 普通类：具体实现
2. 抽象类：具体实现，规范(抽象方法)
3. 接口：规范 
 
 14）使用接口
1. 访问修饰符：只能是public或默认。
2. 接口名：和类名采用相同命名机制。
3. extends：接口可以多继承。
4. 常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是。
5. 方法：接口中的方法只能是：public abstract。 省略的话，也是public abstract

1. 子类通过implements来实现接口中的规范。
2. 接口不能创建实例，但是可用于声明引用变量类型。
3. 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。
4. JDK1.7之前，接口中只能包含静态常量、抽象方法，不能有普通属性、构造方法、普通方法。
5. JDK1.8后，接口中包含普通的静态方法

接口完全支持多继承

15） 内部类 innerclasses
内部类只是一个编译时概念，一旦我们编译成功，就会成为完全不同的两个类。对于一个名为Outer的外部类和其内部定义的名为Inner的内部类。编译完成后会出现Outer.class和Outer$Inner.class两个类的字节码文件。所以内部类是相对独立的一种存在，其成员变量/方法名可以和外部类的相同
内部类的作用：
1. 内部类提供了更好的封装。只能让外部类直接访问，不允许同一个包中的其他类直接访问。
2. 内部类可以直接访问外部类的私有属性，内部类被当成其外部类的成员。 但外部类不能访问内部类的内部属性。
3. 接口只是解决了多重继承的部分问题，而内部类使得多重继承的解决方案变得更加完整。
内部类的使用场合：
1. 由于内部类提供了更好的封装特性，并且可以很方便的访问外部类的属性。所以，在只为外部类提供服务的情况下可以优先考虑使用内部类。
2.使用内部类间接实现多继承：每个内部类都能独立地继承一个类或者实现某些接口，所以无论外部类是否已经继承了某个类或者实现了某些接口，对于内部类没有任何影响

？？？？？？

16）异常 Exception
抛出异常：在执行一个方法时，如果发生异常，则这个方法生成代表该异常的一个对象，停止当前执行路径，并把异常对象提交给JRE
捕获异常：JRE得到该异常后，寻找相应的代码来处理该异常。JRE在方法的调用栈中查找，从生成异常的方法开始回溯，直到找到相应的异常处理代码为止
Throwable 两个子类：
Error Error是程序无法处理的错误
Exception 分为 RuntimeException  CheckedException

异常处理方式：一：try-catch-finally  二：throws

自定义异常

17） 数组
数组长度是确定的一旦被创建了大小就不可改变
元素必须是相同类型的
数组类型可以使任何数据类型


/////////...........

Servlet是JavaWeb的三大组件之一（Servlet、Filter、Listener）
一 . servlet
servlet原理，访问步骤
第一步：容器先加载Servlet类
第二步：容器实例化Servlet(Servlet无参构造函数执行)
第三步：执行init()方法（在Servlet生命周期中，只执行一次，且在service()方法执行前执行）
第四步：执行service()方法，处理客户请求，doPost()或doGet()
第五步：执行destroy()，销毁线程
servlet周期
执行init方法
多次执行service方法
执行destory()方法

servlet常用API
servlet  request和response对象
servlet转发和重定向
servlet cookie和session

servlet  ServletContext对象和ServletConfig对象
1. Context：上下文，理解为环境。环境可以给其内部的个体提供资源。从编程的角度来说可以给内部的对象提供数据；
2. ServletConfig：它是Servlet的私有环境，可以为某一个Servlet提供数据；
3. ServletContext：它是Servlet的公有环境，可以为所有Servlet提供数据；
4. 使用ServletConfig和ServletContext给Servlet预置数据，不用写单独的配置文件，直接使用web.xml即可；另外这两个对象可以在初始化Servlet之前自动读取web.xml中的预置数据；
5. Servlet特殊用法：
    - 可以使用此对象存取一些变量；
    - 即在程序运行阶段随时向此对象存取数据；
    - 获取对象：ServletContext ctx = getServletContext();
    - 取：ctx.getAttribute("user")；
    - 存：ctx.setAttribute("user","admin")；
 6. 通常在Tomcat启动时，都要调用某Servlet重写init(ServletConfig config)方法，专门用来在此阶段初始化项目所需要的一些变量。
ServletContext对象的创建是在服务器启动时完成的；
ServletContext对象的销毁是在服务器关闭时完成的

servlet web.xml文件和server.xml文件:
servlet 域对象

servlet 注解
@WebServlet("/first1")

编码问题


/////////servlet 课程
规范
周期
HttpServletRequest  
HttpServletResponse
请求与响应
重定向
转发
servletContext
cookie
httpsession
监听器
过滤器










